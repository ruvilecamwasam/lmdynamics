# lmdynamics
I have uploaded here all the code from the article "Dynamics and Stability of an Optically Levitated Mirror":

*Lecamwasam, R., Graham, A., Ma, J., Sripathy, K., Guccione, G., Qin, J., ... & Lam, P. K. (2019). Dynamics and Stability of an Optically Levitated Mirror. arXiv preprint arXiv:1912.07789.*

Everything in this repository was written by me, and you may use/modify it with or without citing the manuscript (though please do if you feel it is scholarly appropriate). Legally speaking the repository is released under a GPL v3 Licence, see *LICENCE* or Google "GPL v3" for some plain English discussions.

This code is a mixture of Mathematica, MATLAB, and Python that I wrote as I went, without thinking of it being used by other people. Because of this it is a bit opaque in many areas. I have incluced some instructions below, and if you have any questions at all feel free to send me an email.

Ruvi Lecamwasam

ruvi.lecamwasam@anu.edu.au

# How to use the code

## Figure 2: Adiabatic Regime
Each subfigure is in a different section of the Mathematica notebook *FigAdiabatic.nb*, but you should evaluate the whole thing in order as values generated are sometimes referenced in later parts. The figures will be generated and then exported to the notebook directory. Fig c may take some time while it calculates the frequencies of oscillation.

## Figure 3: Evaluating the Approximation
This consists of two parts: a MATLAB file to generate the data, and a Mathematica notebook to plot it.

### Generating the Data
The MATLAB file *EvaluatingApproximation.m* simulates both the full and approximated dynamics for a given set of dimensionless parametrs and initial conditions, then outputs the following .csv files:

* *fullsys.csv* - The dynamical variables of the full simulation (t,x,px,|a|^2,angle(a)).
* *approxsys.csv* - The dynamical variables of the approximation simulation (x,p).
* *energy.csv* - The dimensionless energy of the full simulation.
* *energya.csv* - The dimensionless energy of the approximate simulation.

The simulation parameters are set in the function ``getInternalParams()``, and the initial conditions in the variable ``yStart``.

Note that there are alread two sets of .csv files in the folder. One set has 'h10_' prepended to it, the parameters corresponding to these are in *h10_params.txt*. The other set does not have anything prepended, and those parameters are in *params.txt*.

### Exporting the Figures
Open and run the notebook *FigEvaluatingApprox.nb*. Each subfigure is in a different cell, but you will have to run them all as variables generated in some parts are used in others. The figures will be exported to the notebook directory.

## Figure 4: Visualisation
Similarly to Figure 3, there is a MATLAB file to  generate the data and a Mathematica notebook to plot it. In fact, the MATLAB file is almost identical apart from exporting different data (this one outputs *phasespace.csv*), and as before you run the cells in the Mathematica notebook *FigVIsualisation.nb* sequentially.

## Figure 5: Two-Laser Trapping & Cooling
We first use two python files to generate the data: *searchTrappingCooling.py* which uses the dimensionless potential and heating rates to find regions which should have simultaneous trapping and cooling, then *testApproximation* which simulates the full equations of motion at these points to find the well widths and depths. We then use the Mathematica notebook *figTrappingCooling.nb* to generate the figures.

The time taken to run this code depends on the size of numerical grid used. The current settings took two days on a Google Cloud Compute Engine with 64 virtual CPUs, so you may want to use a coarser grid if you are doing this on a desktop. Unfortunately the data files generated by this were too large to upload to GitHub, but if you email me I will happily find some way to send them to you.

### Find regions of trapping and cooling
We first run *searchTrappingCooling.py*. This uses the dimensionless potential and heating rates to find regions of simultaneous trapping and cooling, as discussed in III.A of the mansucript. The parameters this finds are saved in the Python Pickle file *searchTrappingCooling.p*.

### Calculate the well widths and depths
The dimensionless potential and heating rates were derived using the first-order correction to the adiabatic approximation. In *testApproximation.py* we test that this is trapping & cooling using the full dynamics, and numerically find the well width and depth as discussed in III.A of the manuscript. This outputs two data files
* *wellNumericParams[eta].csv* - Here [eta] is the particular value of eta which is chosen. This is a .csv file contains points of the form (g, B, Delta, wellWidth, wellCentre, wellDepth).
* *wellAnalyticParams.p* - Same as above but a Python Pickle file. I didn't end up using this, but it remains in the code.

### Generate the figures
Open and run the notebook *FigTrappingCooling.nb*. Each subfigure is in a different cell, but you will have to run them all as variables generated in some parts are used in others. The figures will be exported to the notebook directory.

## Figure 6: Photothermal Effects

The MATLAB file *PhotothermalHeating.m* simulates the full dynamics for given parameters and initial conditions, then outputs the dynamical variables as *photothermal.csv*. The file *crayolaColours.m* is used by *PhotothermalHeating.m* as it generates a real-time plot during the simulation, but you don't have to worry about it. Finally, the Mathematica files *figPhotothermal_Eigenvalues.nb* and *figPhotothermal_Trajectories.nb* generate the figures and export them to the same directory as the notebook.
